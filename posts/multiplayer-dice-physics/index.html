<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.129.0"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=canonical href=https://sarah.engineer/posts/multiplayer-dice-physics/><title>Simulating Multiplayer 3D Dice &#183; sarah.engineer</title>
<meta name=description property="og:description" content="Alternative title: how I cheated the laws of physics and rigged my own dice game"><script type=text/javascript>window.addEventListener("pageshow",e=>{e.persisted&&(document.querySelector(".sidebar").classList.remove("animated-sidebar-reverse"),document.querySelector(".sidebar").classList.remove("animated-sidebar"))});const animateIn=()=>{if(window.location.hash==="#animate"){const e=new URL(window.location);e.hash="",history.replaceState(null,"",e.href),document.querySelector(".sidebar").classList.add("animated-sidebar"),setTimeout(()=>document.querySelector(".sidebar").classList.remove("animated-sidebar"),3e3)}};document.readyState==="loading"?document.addEventListener("readystatechange",animateIn):animateIn(),window.animationSequence=e=>{setTimeout(()=>{window.location.href=e},1010),document.querySelector(".sidebar").classList.remove("animated-sidebar"),setTimeout(()=>{document.querySelector(".sidebar").classList.add("animated-sidebar-reverse")},1)}</script><link type=text/css rel=stylesheet href=../../css/print.css media=print><link type=text/css rel=stylesheet href=../../css/poole.css><link type=text/css rel=stylesheet href=../../css/syntax.css><link type=text/css rel=stylesheet href=../../css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=../../apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=../../favicon.ico><link href=../../posts/multiplayer-dice-physics/index.md rel=alternate type=text/markdown title=sarah.engineer></head><body style=background-color:#434345 class=theme-base-0d><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a onclick='animationSequence("/")'><h1><span class="color-name underline">sarah</span><span class="color-dot underline">.</span><span class=invisible-text>&shy;</span><span class=underline>engineer</span></h1></a><p class=lead>full-stack software engineer â€¢ game designer</p></div><nav><ul class=sidebar-nav><li><a href=../../posts/>Posts</a></li><li><a href=../../links/>Links</a></li><li><a href=../../about/>About</a></li><li><a href=../../contact/>Contact</a></li></ul></nav><p class=copyright>&copy; 2024. All rights reserved.</p></div></aside><div class=main-container><main class="content container"><div class=post><h1>Simulating Multiplayer 3D Dice</h1><time datetime=2022-01-30T22:30:07-0800 class=post-date>Sun, Jan 30, 2022</time><p>I wanted to add 3D, physics-based dice to my online game, <a href=https://rollycubes.com>rolly cubes</a>.</p><p>Synchronizing physics across an online multiplayer game is a non-trival challenge. Generally, it requires running the simulation on an authoritative game server and sending updates to the clients. I tried this approach at first, but I felt I was adding a lot of bloat to my otherwise lightweight server.</p><p>I found surprisingly little information for how people approached this particular problem in the past, so I wanted to write this blog post to document my solution in case it&rsquo;s helpful to anyone else.</p><h2 id=taking-a-step-back>Taking A Step Back</h2><p>My goal was fairly straigtforward: add a 3D dice visualization to the client.</p><p>Previously, the the client/server architecture worked like this:</p><ol><li>The client sends a request to roll the dice.</li><li>The server generates random values and propagates them to all clients.</li><li>The client plays a canned animation based on the values from the server.</li></ol><p>Put together, it looked like this:
<img src=./2d_roll.gif alt="2D Dice Roll Animation"></p><p>Functional, but definitely not 3D.</p><p>I wanted to keep the server logic simple; generate the random values, send them to the client, and let the client worry about simulating the physics. Given this constraint, I needed to build a client that could reliably produce a particular roll.</p><h2 id=getting-started>Getting Started</h2><p>Since my game is web-based, I needed to find a 3D library built in JavaScript. After some research, I decided on <a href=https://www.babylonjs.com/>Babylon.js</a>, which comes with compatibility with several different physics engines.</p><p>I started by creating a simple set of cubes textured as dice, and connecting them up to a physics engine (I chose <a href=https://schteppe.github.io/cannon.js/>cannon.js</a>). Here&rsquo;s what the early stages looked like:
<img src=./early_3d_dice.gif alt="Early 3D dice roll"></p><h2 id=the-difficult-part>The Difficult Part</h2><p>The physics worked great, but there was no way to influence what result was shown on the dice. If I could build a system that could reliably roll the same value every time, I would be most of the way there. I came up with the following plan; each time the client received the random values from the server, it would:</p><ol><li><a href=https://github.com/cgsdev0/rollycubes/blob/8d419a12284569f0c40959a4de6482b603ce759a/client/src/3d/main.ts#L384-L388>Move the dice</a> to the edge of the screen.</li><li>Choose some <a href=https://github.com/cgsdev0/rollycubes/blob/8d419a12284569f0c40959a4de6482b603ce759a/client/src/3d/main.ts#L393-L403>random impulse values</a> to impart on the dice.</li><li><strong><a href=https://github.com/cgsdev0/rollycubes/blob/8d419a12284569f0c40959a4de6482b603ce759a/client/src/3d/main.ts#L410-L414>Run the entire physics simulation in a single frame</a>,</strong> until the dice stop moving.
a. <a href=https://github.com/cgsdev0/rollycubes/blob/8d419a12284569f0c40959a4de6482b603ce759a/client/src/3d/main.ts#L436-L447>Record each tick</a> of the simulation into memory.</li><li><a href=https://github.com/cgsdev0/rollycubes/blob/8d419a12284569f0c40959a4de6482b603ce759a/client/src/3d/main.ts#L24-L45>Calculate the upward face</a> of the dice.</li><li><a href=https://github.com/cgsdev0/rollycubes/blob/8d419a12284569f0c40959a4de6482b603ce759a/client/src/3d/main.ts#L48-L73>Re-map the UVs</a> of the dice, then <a href=https://github.com/cgsdev0/rollycubes/blob/8d419a12284569f0c40959a4de6482b603ce759a/client/src/3d/main.ts#L482-L516>play back</a> the recorded simulation.</li></ol><p>All of the code for the 3D simulation lives in <a href=https://github.com/cgsdev0/rollycubes/blob/8d419a12284569f0c40959a4de6482b603ce759a/client/src/3d/main.ts>this file</a>; I apologize for the mess.</p><p>With this code done, the final step was to <strong>tweak the UVs of the dice further</strong> before playing the roll, so that I could display the results of the dice on the top faces of the dice. I did this by introducing a variable called <code>fudge</code> that would be added to the UV indexes, and shift the rotation by that amount.</p><h2 id=conclusion>Conclusion</h2><p>The problem of simulating dice physics doesn&rsquo;t <em>actually</em> require physics synchronization; all you need is to be able to produce the desired dice roll consistently in the client. In my solution, each client will actually see a different physics simulation, but will always see the same result. The secret sauce is <strong>pre-calculating the end result of the simulation</strong>, and then <strong>fudging the texture UVs</strong> to produce the roll you want.</p><p>It&rsquo;s theoretically possible to use this solution to display the same simulation to each client as well, by seeding the physics with another random value from the server (and using a deterministic physics engine). This wasn&rsquo;t a design goal for me, though, so I didn&rsquo;t bother.</p><p>If you want to see the finished project in action, please check out <a href=https://github.com/cgsdev0/rollycubes#dice-game>rolly cubes</a>!</p></div></main></div></body></html>